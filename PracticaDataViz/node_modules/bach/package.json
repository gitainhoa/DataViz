{
  "_args": [
    [
      {
        "raw": "bach@^0.5.0",
        "scope": null,
        "escapedName": "bach",
        "name": "bach",
        "rawSpec": "^0.5.0",
        "spec": ">=0.5.0 <0.6.0",
        "type": "range"
      },
      "/Users/miguelmonzon/Documents/GitProyects/DataViz-DojoRandori/node_modules/undertaker"
    ]
  ],
  "_from": "bach@>=0.5.0 <0.6.0",
  "_id": "bach@0.5.0",
  "_inCache": true,
  "_location": "/bach",
  "_nodeVersion": "0.10.41",
  "_npmOperationalInternal": {
    "host": "packages-5-east.internal.npmjs.com",
    "tmp": "tmp/bach-0.5.0.tgz_1455230405207_0.7704204828478396"
  },
  "_npmUser": {
    "name": "phated",
    "email": "blaine@iceddev.com"
  },
  "_npmVersion": "2.14.14",
  "_phantomChildren": {},
  "_requested": {
    "raw": "bach@^0.5.0",
    "scope": null,
    "escapedName": "bach",
    "name": "bach",
    "rawSpec": "^0.5.0",
    "spec": ">=0.5.0 <0.6.0",
    "type": "range"
  },
  "_requiredBy": [
    "/undertaker"
  ],
  "_resolved": "https://registry.npmjs.org/bach/-/bach-0.5.0.tgz",
  "_shasum": "3ffa6a3741773ebc0d24be5fda4bc5e85b5b1da1",
  "_shrinkwrap": null,
  "_spec": "bach@^0.5.0",
  "_where": "/Users/miguelmonzon/Documents/GitProyects/DataViz-DojoRandori/node_modules/undertaker",
  "author": {
    "name": "Blaine Bublitz",
    "email": "blaine@iceddev.com",
    "url": "http://iceddev.com/"
  },
  "bugs": {
    "url": "https://github.com/gulpjs/bach/issues"
  },
  "contributors": [
    {
      "name": "Blaine Bublitz",
      "email": "blaine@iceddev.com",
      "url": "http://iceddev.com/"
    },
    {
      "name": "Pawel Kozlowski",
      "email": "pkozlowski.opensource@gmail.com"
    },
    {
      "name": "Benjamin Tan",
      "email": "demoneaux@gmail.com",
      "url": "https://d10.github.io/"
    }
  ],
  "dependencies": {
    "async-done": "^1.1.1",
    "async-settle": "^0.2.1",
    "lodash.filter": "^4.1.0",
    "lodash.flatten": "^4.0.0",
    "lodash.foreach": "^4.0.0",
    "lodash.initial": "^4.0.1",
    "lodash.last": "^3.0.0",
    "lodash.map": "^4.1.0",
    "now-and-later": "0.0.6"
  },
  "description": "Compose your async functions with elegance",
  "devDependencies": {
    "code": "^1.5.0",
    "eslint": "^1.7.3",
    "eslint-config-gulp": "^2.0.0",
    "jscs": "^2.3.5",
    "jscs-preset-gulp": "^1.0.0",
    "lab": "^6.2.0"
  },
  "directories": {},
  "dist": {
    "shasum": "3ffa6a3741773ebc0d24be5fda4bc5e85b5b1da1",
    "tarball": "https://registry.npmjs.org/bach/-/bach-0.5.0.tgz"
  },
  "engines": {
    "node": ">= 0.10"
  },
  "files": [
    "index.js",
    "lib",
    "LICENSE"
  ],
  "gitHead": "fa971c5fc6207cfdd666014cf914e0c24fb6b49e",
  "homepage": "https://github.com/gulpjs/bach#readme",
  "keywords": [
    "compose",
    "fluent",
    "composing",
    "continuation",
    "function composition",
    "functional",
    "async",
    "map",
    "series",
    "parallel",
    "extension",
    "tracing",
    "debug",
    "timing",
    "aop",
    "settle",
    "promises",
    "callbacks",
    "observables",
    "streams",
    "end",
    "completion",
    "complete",
    "finish",
    "done",
    "error handling"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "phated",
      "email": "blaine@iceddev.com"
    }
  ],
  "name": "bach",
  "optionalDependencies": {},
  "readme": "bach\n====\n\n[![build status](https://secure.travis-ci.org/gulpjs/bach.png)](http://travis-ci.org/gulpjs/bach)\n\nCompose your async functions with elegance\n\n## Usage\n\nWith Bach, it is very easy to compose async functions to run in series or parallel.\n\n```js\nvar bach = require('bach');\n\nfunction fn1(cb){\n  cb(null, 1);\n}\n\nfunction fn2(cb){\n  cb(null, 2);\n}\n\nfunction fn3(cb){\n  cb(null, 3);\n}\n\nvar seriesFn = bach.series(fn1, fn2, fn3);\n// fn1, fn2, and fn3 will be run in series\nseriesFn(function(err, res){\n  if(err){ // in this example, err is undefined\n    // handle error\n  }\n  // handle results\n  // in this example, res is [1, 2, 3]\n});\n\nvar parallelFn = bach.parallel(fn1, fn2, fn3);\n// fn1, fn2, and fn3 will be run in parallel\nparallelFn(function(err, res){\n  if(err){ // in this example, err is undefined\n    // handle error\n  }\n  // handle results\n  // in this example, res is [1, 2, 3]\n});\n```\n\nSince the composer functions just return a function that can be called, you can combine them.\n\n```js\nvar combinedFn = bach.series(fn1, bach.parallel(fn2, fn3));\n// fn1 will be executed before fn2 and fn3 are run in parallel\ncombinedFn(function(err, res){\n  if(err){ // in this example, err is undefined\n    // handle error\n  }\n  // handle results\n  // in this example, res is [1, [2, 3]]\n});\n```\n\nFunctions are called with [async-done](https://github.com/gulpjs/async-done), so you can return a stream or promise.\nThe function will complete when the stream ends/closes/errors or the promise fulfills/rejects.\n\n```js\n// streams\nvar fs = require('fs');\n\nfunction streamFn1(){\n  return fs.createReadStream('./example')\n    .pipe(fs.createWriteStream('./example'));\n}\n\nfunction streamFn2(){\n  return fs.createReadStream('./example')\n    .pipe(fs.createWriteStream('./example'));\n}\n\nvar parallelStreams = bach.parallel(streamFn1, streamFn2);\nparallelStreams(function(err){\n  if(err){ // in this example, err is undefined\n    // handle error\n  }\n  // all streams have emitted an 'end' or 'close' event\n});\n```\n\n```js\n// promises\nvar when = require('when');\n\nfunction promiseFn1(){\n  return when.resolve(1);\n}\n\nfunction promiseFn2(){\n  return when.resolve(2);\n}\n\nvar parallelPromises = bach.parallel(promiseFn1, promiseFn2);\nparallelPromises(function(err, res){\n  if(err){ // in this example, err is undefined\n    // handle error\n  }\n  // handle results\n  // in this example, res is [1, 2]\n});\n```\n\nAll errors are caught in a [domain](http://nodejs.org/api/domain.html) and passed to the final callback as the first argument.\n\n```js\nfunction success(cb){\n  setTimeout(function(){\n    cb(null, 1);\n  }, 500);\n}\n\nfunction error(){\n  throw new Error('Thrown Error');\n}\n\nvar errorThrownFn = bach.parallel(error, success);\nerrorThrownFn(function(err, res){\n  if(err){\n    // handle error\n    // in this example, err is an error caught by the domain\n  }\n  // handle results\n  // in this example, res is [undefined]\n});\n```\n\nSomething that may be encountered when an error happens in a parallel composition is the callback\nwill be called as soon as the error happens. If you want to continue on error and wait until all\nfunctions have finished before calling the callback, use `settleSeries` or `settleParallel`.\n\n```js\nfunction success(cb){\n  setTimeout(function(){\n    cb(null, 1);\n  }, 500);\n}\n\nfunction error(cb){\n  cb(new Error('Async Error'));\n}\n\nvar parallelSettlingFn = bach.settleParallel(success, error);\nparallelSettlingFn(function(err, res){\n  // all functions have finished executing\n  if(err){\n    // handle error\n    // in this example, err is an error passed to the callback\n  }\n  // handle results\n  // in this example, res is [1]\n});\n```\n\n## API\n\n__All bach APIs return an invoker function that takes a single callback as its only parameter.\nThe function signature is `function(error, results)`.__\n\nEach method can optionally be passed an object of [extension point functions](#extension-points)\nas the last argument.\n\n### `series(fns..., [extensions])` => Function\n\nAll functions (`fns`) passed to this function will be called in series when the returned function is\ncalled.  If an error occurs, execution will stop and the error will be passed to the callback function\nas the first parameter.\n\n__The error parameter will always be a single error.__\n\n### `parallel(fns..., [extensions])` => Function\n\nAll functions (`fns`) passed to this function will be called in parallel when the returned\nfunction is called.  If an error occurs, the error will be passed to the callback function\nas the first parameter. Any async functions that have not completed, will still complete,\nbut their results will __not__ be available.\n\n__The error parameter will always be a single error.__\n\n### `settleSeries(fns..., [extensions])` => Function\n\nAll functions (`fns`) passed to this function will be called in series when the returned function is\ncalled. All functions will always be called and the callback will receive all settled errors and results.\n\n__The error parameter will always be an array of errors.__\n\n### `settleParallel(fns..., [extensions])` => Function\n\nAll functions (`fns`) passed to this function will be called in parallel when the returned function is\ncalled. All functions will always be called and the callback will receive all settled errors and results.\n\n__The error parameter will always be an array of errors.__\n\n### Extension Points\n\nAn extension point object can contain:\n\n#### `create(fn, key)` => `storage` object\n\nCalled before the async function or extension points are called. Receives the function and key to be\nexecuted in the future.  The return value should be any object and will be passed to the other extension\npoint methods.  The storage object can keep any information needed between extension points and can\nbe mutated within extension points.\n\n#### `before(storage)`\n\nCalled before the async function is executed. Receives the storage object returned from the `create`\nextension point.\n\n#### `after(storage)`\n\nCalled after the async function is executed and completes successfully. Receives the storage object\nreturned from the `create` extension point.\n\n#### `error(storage)`\n\nCalled after the async function is executed and errors. Receives the storage object returned from\nthe `create` extension point.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/gulpjs/bach.git"
  },
  "scripts": {
    "lint": "eslint . && jscs *.js lib/ test/",
    "pretest": "npm run lint",
    "test": "lab -cv"
  },
  "version": "0.5.0"
}
