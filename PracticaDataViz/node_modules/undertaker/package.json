{
  "_args": [
    [
      {
        "raw": "undertaker@^0.15.0",
        "scope": null,
        "escapedName": "undertaker",
        "name": "undertaker",
        "rawSpec": "^0.15.0",
        "spec": ">=0.15.0 <0.16.0",
        "type": "range"
      },
      "/Users/miguelmonzon/Documents/GitProyects/DataViz-DojoRandori/node_modules/gulp"
    ]
  ],
  "_from": "undertaker@>=0.15.0 <0.16.0",
  "_id": "undertaker@0.15.0",
  "_inCache": true,
  "_location": "/undertaker",
  "_nodeVersion": "0.10.41",
  "_npmOperationalInternal": {
    "host": "packages-5-east.internal.npmjs.com",
    "tmp": "tmp/undertaker-0.15.0.tgz_1456450601162_0.7742155257146806"
  },
  "_npmUser": {
    "name": "phated",
    "email": "blaine@iceddev.com"
  },
  "_npmVersion": "2.14.14",
  "_phantomChildren": {},
  "_requested": {
    "raw": "undertaker@^0.15.0",
    "scope": null,
    "escapedName": "undertaker",
    "name": "undertaker",
    "rawSpec": "^0.15.0",
    "spec": ">=0.15.0 <0.16.0",
    "type": "range"
  },
  "_requiredBy": [
    "/gulp"
  ],
  "_resolved": "https://registry.npmjs.org/undertaker/-/undertaker-0.15.0.tgz",
  "_shasum": "04b325d8ac40b361e2b8fc6a89fee9daf9e739b6",
  "_shrinkwrap": null,
  "_spec": "undertaker@^0.15.0",
  "_where": "/Users/miguelmonzon/Documents/GitProyects/DataViz-DojoRandori/node_modules/gulp",
  "author": {
    "name": "Blaine Bublitz",
    "email": "blaine@iceddev.com",
    "url": "http://iceddev.com/"
  },
  "bugs": {
    "url": "https://github.com/phated/undertaker/issues"
  },
  "contributors": [
    {
      "name": "Damien Lebrun",
      "email": "dinoboff@hotmail.com"
    }
  ],
  "dependencies": {
    "bach": "^0.5.0",
    "es6-weak-map": "^2.0.1",
    "last-run": "^1.1.0",
    "lodash.defaults": "^4.0.1",
    "lodash.flatten": "^4.0.0",
    "lodash.map": "^4.1.0",
    "lodash.reduce": "^4.1.0",
    "undertaker-registry": "^1.0.0"
  },
  "description": "Task registry that allows composition through series/parallel methods.",
  "devDependencies": {
    "async-once": "^1.0.0",
    "code": "^1.2.1",
    "del": "^2.0.2",
    "eslint": "^1.7.3",
    "eslint-config-gulp": "^2.0.0",
    "gulp-jshint": "^1.8.4",
    "jscs": "^2.3.5",
    "jscs-preset-gulp": "^1.0.0",
    "lab": "^6.2.0",
    "once": "^1.3.1",
    "through2": "^2.0.0",
    "undertaker-common-tasks": "^1.0.0",
    "undertaker-task-metadata": "^1.0.0",
    "vinyl-fs": "^2.2.0"
  },
  "directories": {},
  "dist": {
    "shasum": "04b325d8ac40b361e2b8fc6a89fee9daf9e739b6",
    "tarball": "https://registry.npmjs.org/undertaker/-/undertaker-0.15.0.tgz"
  },
  "engines": {
    "node": ">= 0.10"
  },
  "files": [
    "LICENSE",
    "index.js",
    "lib"
  ],
  "gitHead": "1c868e6cff6de268610c24d7e7087e49023426f4",
  "homepage": "https://github.com/phated/undertaker#readme",
  "keywords": [
    "registry",
    "runner",
    "task"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "phated",
      "email": "blaine@iceddev.com"
    }
  ],
  "name": "undertaker",
  "optionalDependencies": {},
  "readme": "undertaker\n==========\n\n[![Build Status](https://travis-ci.org/gulpjs/undertaker.svg?branch=master)](https://travis-ci.org/gulpjs/undertaker)\n\nTask registry that allows composition through `series`/`parallel` methods.\n\n## Usage\n\n```js\nvar fs = require('fs');\nvar Undertaker = require('undertaker');\n\nvar taker = new Undertaker();\n\ntaker.task('task1', function(cb){\n  // do things\n\n  cb(); // when everything is done\n});\n\ntaker.task('task2', function(){\n  return fs.createReadStream('./myFile.js')\n    .pipe(fs.createWriteStream('./myFile.copy.js'));\n});\n\ntaker.task('task3', function(){\n  return new Promise(function(resolve, reject){\n    // do things\n\n    resolve(); // when everything is done\n  });\n});\n\ntaker.task('combined', taker.series('task1', 'task2'));\n\ntaker.task('all', taker.parallel('combined', 'task3'));\n```\n\n## API\n\n__Task functions can be completed in any of the ways supported by\n[`async-done`](https://github.com/phated/async-done#completion-and-error-resolution)__\n\n### `new Undertaker([RegistryConstructor])`\n\nThe constructor is used to create a new instance of `Undertaker`. Each instance of\n`Undertaker` gets its own instance of a registry. By default, the registry is an\ninstance of [`undertaker-registry`](https://github.com/gulpjs/undertaker-registry)\nbut it can be any other registry that follows the [Custom Registries API](#custom-registries).\n\nTo use a custom registry, pass the custom registry's constructor function when\ninstantiating a new `Undertaker` instance. This will use the custom constructor\nto create the registry for this instance.\n\n### `task([taskName,] fn)` => [Function]\n\nBoth a `getter` and `setter` for tasks.\n\nIf a string (`taskName`) is given as the only argument, it behaves as a `getter`\nand returns the registered function.\n\nIf a function (`fn`) and optionally a string (`taskName`) is given, it behaves as\na `setter` and will register the task by the `taskName`.  If `taskName` is not\nspecified, the `name` or `displayName` property of the function is used as the `taskName`.\n\n__Note: If you attempt to register the same function with different names, it will\nonly be registered by the last name attempted.__\n\nWill throw if:\n\n* `taskName` is missing or not a string when behaving as a `getter` or\nis missing and function is anonymous when behaving as a `setter`.\n* `fn` is missing or not a function when behaving as a `setter`.\n\n### `series(taskName || fn...)` => Function\n\nTakes a variable amount of strings (`taskName`) and/or functions (`fn`) and\nreturns a function of the composed tasks or functions. Any `taskNames` are\nretrieved from the registry using the `get` method.\n\nWhen the returned function is executed, the tasks or functions will be executed\nin series, each waiting for the prior to finish. If an error occurs, execution\nwill stop.\n\n### `parallel(taskName || fn...)` => Function\n\nTakes a variable amount of strings (`taskName`) and/or functions (`fn`) and\nreturns a function of the composed tasks or functions. Any `taskNames` are\nretrieved from the registry using the `get` method.\n\nWhen the returned function is executed, the tasks or functions will be executed\nin parallel, all being executed at the same time. If an error occurs, all execution\nwill complete.\n\n### `registry([registryInstance])`\n\nOptionally takes an instantiated registry object. If no arguments are passed, returns\nthe current registry object. If an instance of a registry (`customRegistry`) is passed\nthe tasks from the current registry will be transferred to it and the current registry\nwill be replaced with the new registry.\n\nThe ability to assign new registries will allow you to pre-define/share tasks or add\ncustom functionality to your registries. See [Custom Registries](#custom-registries)\nfor more information.\n\n### `tree([options])` => Object\n\nOptionally takes an object (`options`) and returns an object representing the\ntree of registered tasks. The object returned is [`archy`](https://www.npmjs.org/package/archy)\ncompatible when assigned to the `nodes` key. Also, each node has a `type`\nproperty that can be used to determine if the node is a `task` or `function`.\n\n#### `options`\n\n* `deep` - if the whole tree should be returned (Default: `false`)\n\n### `lastRun(task, [timeResolution])` => [Timestamp]\n\nTakes a string or function (`task`) and returns a timestamp of the last time the task\nwas run successfully. The time will be the time the task started.\n\nReturns `undefined` if the task has not been run.\n\nIf a task errors, the result of `lastRun` will be undefined because the task\nshould probably be re-run from scratch to get into a good state again.\n\nThe timestamp is always given in millisecond but the time resolution can be\nreduced (rounded down). The use case is to be able to compare a build time\nto a file time attribute. On node v0.10 or with file system like HFS or FAT,\n`fs.stat` time attributes like `mtime` precision is one second.\n\nAssuming `undertakerInst.lastRun('someTask')` returns `1426000001111`,\n`undertakerInst.lastRun('someTask', 1000)` returns `1426000001000`.\n\nThe default time resolution is `1000` on node v0.10, `0` on node 0.11+ and iojs.\nit can be overwritten using `UNDERTAKER_TIME_RESOLUTION` environment variable.\n\n__Note: if you use a custom registry that modifies the function (such as `.bind`),\nyou will need to use the string for `task` instead of a function because we have no\nway of looking up the function that was altered.__\n\n## Custom Registries\n\nCustom registries are constructor functions allowing you to pre-define/share tasks\nor add custom functionality to your registries.\n\nA registry's prototype should define:\n\n- `init(taker)`: receives the undertaker instance to set pre-defined tasks using the `task(taskName, fn)` method.\n- `get(taskName)`: returns the task with that name\n   or `undefined` if no task is registered with that name.\n- `set(taskName, fn)`: add task to the registry. If `set` modifies a task, it should return the new task.\n- `tasks()`: returns an object listing all tasks in the registry.\n\nYou should not call these functions yourself; leave that to Undertaker, so it can\nkeep its metadata consistent.\n\nThe easiest way to create a custom registry is to inherit from\n[undertaker-registry](https://www.npmjs.com/package/undertaker-registry):\n\n```javascript\nvar util = require('util');\n\nvar DefaultRegistry = require('undertaker-registry');\n\nfunction MyRegistry(){\n  DefaultRegistry.call(this);\n}\n\nutil.inherits(MyRegistry, DefaultRegistry);\n\nmodule.exports = MyRegistry;\n```\n\n### Sharing tasks\n\nTo share common tasks with all your projects, you can expose an `init` method on the registry\nprototype and it will receive the Undertaker instance as the only argument. You can then use\n`undertaker.task(name, fn)` to register pre-defined tasks.\n\nFor example you might want to share a `clean` task:\n\n```javascript\nvar fs = require('fs');\nvar util = require('util');\n\nvar DefaultRegistry = require('undertaker-registry');\nvar del = require('del');\n\nfunction CommonRegistry(opts){\n  DefaultRegistry.call(this);\n\n  opts = opts || {};\n\n  this.buildDir = opts.buildDir || './build';\n}\n\nutil.inherits(CommonRegistry, DefaultRegistry);\n\nCommonRegistry.prototype.init = function(takerInst){\n  var buildDir = this.buildDir;\n  var exists = fs.existsSync(buildDir);\n\n  if(exists){\n    throw new Error('Cannot initialize common tasks. ' + buildDir + ' directory exists.');\n  }\n\n  takerInst.task('clean', function(){\n    return del([buildDir]);\n  });\n}\n\nmodule.exports = CommonRegistry;\n```\n\nThen to use it in a project:\n```javascript\nvar Undertaker = require('undertaker');\nvar CommonRegistry = require('myorg-common-tasks');\n\nvar taker = new Undertaker(CommonRegistry({ buildDir: '/dist' }));\n\ntaker.task('build', taker.series('clean', function build(cb) {\n  // do things\n  cb();\n}));\n```\n\n### Sharing Functionalities\n\nBy controlling how tasks are added to the registry, you can decorate them.\n\nFor example if you wanted all tasks to share some data,  you can use a custom registry\nto bind them to that data. Be sure to return the altered task, as per the description\nof registry methods above:\n\n```javascript\nvar util = require('util');\n\nvar Undertaker = require('undertaker');\nvar DefaultRegistry = require('undertaker-registry');\n\n// Some task defined somewhere else\nvar BuildRegistry = require('./build.js');\nvar ServeRegistry = require('./serve.js');\n\nfunction ConfigRegistry(config){\n  DefaultRegistry.call(this);\n  this.config = config;\n}\n\nutil.inherits(ConfigRegistry, DefaultRegistry);\n\nConfigRegistry.prototype.set = function set(name, fn) {\n  // The `DefaultRegistry` uses `this._tasks` for storage.\n  var task = this._tasks[name] = fn.bind(this.config);\n  return task;\n};\n\nvar taker = new Undertaker();\n\ntaker.registry(new BuildRegistry());\ntaker.registry(new ServeRegistry());\n\n// `taker.registry` will reset each task in the registry with\n// `ConfigRegistry.prototype.set` which will bind them to the config object.\ntaker.registry(new ConfigRegistry({\n  src: './src',\n  build: './build',\n  bindTo: '0.0.0.0:8888'\n}));\n\ntaker.task('default', taker.series('clean', 'build', 'serve', function(cb) {\n  console.log('Server bind to ' + this.bindTo);\n  console.log('Serving' + this.build);\n  cb();\n}));\n```\n\n### In the wild\n\n* [undertaker-registry](https://github.com/gulpjs/undertaker-registry) - Custom registries probably want to inherit from this.\n* [undertaker-forward-reference](https://github.com/gulpjs/undertaker-forward-reference) - Custom registry supporting forward referenced tasks (similar to gulp 3.x).\n* [undertaker-task-metadata](https://github.com/gulpjs/undertaker-task-metadata) - Proof-of-concept custom registry that attaches metadata to each task.\n* [undertaker-common-tasks](https://github.com/gulpjs/undertaker-common-tasks) - Proof-of-concept custom registry that pre-defines some tasks.\n* [alchemist-gulp](https://github.com/webdesserts/alchemist-gulp) - A default set of tasks for building alchemist plugins.\n* [gulp-hub](https://github.com/frankwallis/gulp-hub/tree/registry-init) - Custom registry to run tasks in multiple gulpfiles. (In a branch as of this writing)\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/phated/undertaker.git"
  },
  "scripts": {
    "lint": "eslint . && jscs *.js lib/ test/*.js",
    "pretest": "npm run lint",
    "test": "lab -cv --ignore store@sparkles"
  },
  "version": "0.15.0"
}
